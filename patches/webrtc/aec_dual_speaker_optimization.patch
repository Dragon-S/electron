From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: lorne <lorne.shi@gmail.com>
Date: Tue, 26 Dec 2023 18:21:46 +0800
Subject: AEC dual speaker optimization
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

AEC双讲检测优化

diff --git a/modules/audio_processing/aec3/dominant_nearend_detector.cc b/modules/audio_processing/aec3/dominant_nearend_detector.cc
index 40073cf6154849e306821142b392e4af0c482110..8ebeb70cb80ea0d3d46d12f272b67ff9a712fc19 100644
--- a/modules/audio_processing/aec3/dominant_nearend_detector.cc
+++ b/modules/audio_processing/aec3/dominant_nearend_detector.cc
@@ -33,7 +33,8 @@ void DominantNearendDetector::Update(
         residual_echo_spectrum,
     rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>>
         comfort_noise_spectrum,
-    bool initial_state) {
+    bool initial_state,
+    bool DTD) {
   nearend_state_ = false;
 
   auto low_frequency_energy = [](rtc::ArrayView<const float> spectrum) {
@@ -69,7 +70,7 @@ void DominantNearendDetector::Update(
 
     // Remain in any nearend mode for a certain duration.
     hold_counters_[ch] = std::max(0, hold_counters_[ch] - 1);
-    nearend_state_ = nearend_state_ || hold_counters_[ch] > 0;
+    nearend_state_ = nearend_state_ || hold_counters_[ch] > 0 || DTD;
   }
 }
 }  // namespace webrtc
diff --git a/modules/audio_processing/aec3/dominant_nearend_detector.h b/modules/audio_processing/aec3/dominant_nearend_detector.h
index 046d1488d6dbcc64d8e3aaa7a0164853a91fad73..bfefa0a8c13656fe7deb36bc0e8ac457fa16636e 100644
--- a/modules/audio_processing/aec3/dominant_nearend_detector.h
+++ b/modules/audio_processing/aec3/dominant_nearend_detector.h
@@ -35,7 +35,8 @@ class DominantNearendDetector : public NearendDetector {
                   residual_echo_spectrum,
               rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>>
                   comfort_noise_spectrum,
-              bool initial_state) override;
+              bool initial_state,
+              bool DTD) override;
 
  private:
   const float enr_threshold_;
diff --git a/modules/audio_processing/aec3/echo_remover.cc b/modules/audio_processing/aec3/echo_remover.cc
index 953d067f443a0a9e927ce9909eb43adee0d835d7..8037a1851f692c363b667d349966d4e4519b4f8e 100644
--- a/modules/audio_processing/aec3/echo_remover.cc
+++ b/modules/audio_processing/aec3/echo_remover.cc
@@ -142,6 +142,12 @@ class EchoRemoverImpl final : public EchoRemover {
   void FormLinearFilterOutput(const SubtractorOutput& subtractor_output,
                               rtc::ArrayView<float> output);
 
+  bool CorrelateDTD(rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>> error,
+                  rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>> capture,
+                  rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>> remote);
+
+  bool FlatnessDTD(rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>> error);
+
   static std::atomic<int> instance_count_;
   const EchoCanceller3Config config_;
   const Aec3Fft fft_;
@@ -178,6 +184,10 @@ class EchoRemoverImpl final : public EchoRemover {
   std::vector<FftData> comfort_noise_heap_;
   std::vector<FftData> high_band_comfort_noise_heap_;
   std::vector<SubtractorOutput> subtractor_output_heap_;
+  std::vector<std::array<float, 2>> long_term_correlate_;
+  std::vector<std::array<float, 2>> long_term_residual_;
+  std::vector<float> long_term_flatness_;
+  std::vector<float> short_term_flatness_;
 };
 
 std::atomic<int> EchoRemoverImpl::instance_count_(0);
@@ -223,7 +233,11 @@ EchoRemoverImpl::EchoRemoverImpl(const EchoCanceller3Config& config,
       E_heap_(NumChannelsOnHeap(num_capture_channels_)),
       comfort_noise_heap_(NumChannelsOnHeap(num_capture_channels_)),
       high_band_comfort_noise_heap_(NumChannelsOnHeap(num_capture_channels_)),
-      subtractor_output_heap_(NumChannelsOnHeap(num_capture_channels_)) {
+      subtractor_output_heap_(NumChannelsOnHeap(num_capture_channels_)),
+      long_term_correlate_(num_capture_channels, {0.0f}),
+      long_term_residual_(num_capture_channels, {0.0f}),
+      long_term_flatness_(num_capture_channels, -100.0f),
+      short_term_flatness_(num_capture_channels, -100.0f) {
   RTC_DCHECK(ValidFullBandRate(sample_rate_hz));
 }
 
@@ -417,6 +431,14 @@ void EchoRemoverImpl::ProcessCapture(
   // is used.
   std::array<float, kFftLengthBy2Plus1> G;
   if (capture_output_used_) {
+    // correlate based DTD
+    bool DTD = false;
+    if (aec_state_.UsableLinearEstimate()) {
+      bool condition1 = CorrelateDTD(E2, Y2, render_buffer->Spectrum(0));
+      bool condition2 = FlatnessDTD(E2);
+      DTD = condition1 && condition2;
+    }
+
     // Estimate the residual echo power.
     residual_echo_estimator_.Estimate(aec_state_, *render_buffer, S2_linear, Y2,
                                       suppression_gain_.IsDominantNearend(), R2,
@@ -445,7 +467,7 @@ void EchoRemoverImpl::ProcessCapture(
     float high_bands_gain;
     suppression_gain_.GetGain(nearend_spectrum, echo_spectrum, R2, R2_unbounded,
                               cng_.NoiseSpectrum(), render_signal_analyzer_,
-                              aec_state_, x, clock_drift, &high_bands_gain, &G);
+                              aec_state_, x, clock_drift, &high_bands_gain, &G, DTD);
 
     suppression_filter_.ApplyGain(comfort_noise, high_band_comfort_noise, G,
                                   high_bands_gain, Y_fft, y);
@@ -516,6 +538,108 @@ void EchoRemoverImpl::FormLinearFilterOutput(
   refined_filter_output_last_selected_ = use_refined_output;
 }
 
+// a correlate based method for DTD
+// return TRUE if nearend voice activate detected when remote voice activated
+bool EchoRemoverImpl::CorrelateDTD(rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>> error,
+                  rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>> capture,
+                  rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>> remote) {
+  // e-x correlate
+  float feature1 = -100.0f;
+  for (size_t i = 0; i < error.size(); i++) {
+    float EX = 0.0f, EE = 0.0f, XX = 0.0f;
+    for (size_t j = 0; j < kFftLengthBy2Plus1 / 2; j++) {
+      EE += error[i][j] * error[i][j];
+      XX += remote[i][j] * remote[i][j];
+      EX += error[i][j] * remote[i][j];
+    }
+    float temp = EX / sqrtf(XX * EE + 1e-6f);
+    float correlateLow = 0.999f * long_term_correlate_[i][0] + 0.001f * temp;
+    long_term_correlate_[i][0] = correlateLow < 1.0f ? correlateLow : 1.0f;
+
+    EX = EE = XX = 0.0f;
+    for (size_t j = kFftLengthBy2Plus1 / 2; j < kFftLengthBy2Plus1 - 1; j++) {
+      EE += error[i][j] * error[i][j];
+      XX += remote[i][j] * remote[i][j];
+      EX += error[i][j] * remote[i][j];
+    }
+    temp = EX / sqrtf(XX * EE + 1e-6f);
+    float correlateHigh = 0.999f * long_term_correlate_[i][1] + 0.001f * temp;
+    long_term_correlate_[i][1] = correlateHigh < 1.0f ? correlateHigh : 1.0f;
+
+    temp = long_term_correlate_[i][1] / (long_term_correlate_[i][0] + 1e-6f);
+    feature1 = feature1 < temp ? temp : feature1;
+  }
+
+  // e-y residual
+  float feature2 = -100.0f;
+  for (size_t i = 0; i < error.size(); i++) {
+    float E = 0.0f, Y = 0.0f;
+    for (size_t j = 0; j < kFftLengthBy2Plus1 / 2; j++) {
+      E += error[i][j];
+      Y += capture[i][j];
+    }
+    float temp = E / (Y + 1e-6f);
+    float residualLow = 0.999f * long_term_residual_[i][0] + 0.001f * temp;
+    long_term_residual_[i][0] = residualLow < 1.0f ? residualLow : 1.0f;
+
+    E = Y = 0.0f;
+    for (size_t j = kFftLengthBy2Plus1 / 2; j < kFftLengthBy2Plus1 - 1; j++) {
+      E += error[i][j];
+      Y += capture[i][j];
+    }
+    temp = E / (Y + 1e-6f);
+    float residualHigh = 0.999f * long_term_residual_[i][1] + 0.001f * temp;
+    long_term_residual_[i][1] = residualHigh < 1.0f ? residualHigh : 1.0f;
+
+    temp = long_term_residual_[i][1] / (long_term_residual_[i][0] + 1e-6f);
+    feature2 = feature2 < temp ? temp : feature2;
+  }
+
+  return feature1 > 0.95f && feature2 > 0.85f;
+}
+
+// a flatness based method for DTD
+bool EchoRemoverImpl::FlatnessDTD(rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>> error) {
+  // e flatness
+  float feature = -100.0f;
+  for (size_t i = 0; i < error.size(); i++) {
+    float temp1 = 0.0f, temp2 = 0.0f;
+    for (size_t j = 0; j < kFftLengthBy2Plus1 / 2; j++) {
+      temp1 += logf(error[i][j] + 1e-6f);
+      temp2 += error[i][j];
+    }
+    float geomitricMeanLow = expf(temp1 / (float)(kFftLengthBy2Plus1 / 2.0f));
+    float arithmeticMeanLow = temp2 / (float)(kFftLengthBy2Plus1 / 2.0f);
+    float flatnessLow = geomitricMeanLow / (arithmeticMeanLow + 1e-6f);
+
+    temp1 = temp2 = 0.0f;
+    for (size_t j = kFftLengthBy2Plus1 / 2; j < kFftLengthBy2Plus1 - 1; j++) {
+      temp1 += logf(error[i][j] + 1e-6f);
+      temp2 += error[i][j];
+    }
+    float geomitricMeanHigh = expf(temp1 / (float)(kFftLengthBy2Plus1 / 2.0f));
+    float arithmeticMeanHigh = temp2 / (float)(kFftLengthBy2Plus1 / 2.0f);
+    float flatnessHigh = geomitricMeanHigh / (arithmeticMeanHigh + 1e-6f);
+
+    float temp = flatnessHigh / (flatnessLow + 1e-6f);
+    if (long_term_flatness_[i] < 0.0f) {
+      long_term_flatness_[i] = temp;
+    } else {
+      long_term_flatness_[i] = 0.9999f * long_term_flatness_[i] + 0.0001f * temp;
+    }
+    if (short_term_flatness_[i] < 0.0f) {
+      short_term_flatness_[i] = temp;
+    } else {
+      short_term_flatness_[i] = 0.9f * short_term_flatness_[i] + 0.1f * temp;
+    }
+
+    temp = short_term_flatness_[i] / (long_term_flatness_[i] + 1e-6f);
+    feature = feature < temp ? temp : feature;
+  }
+
+  return feature > 1.2f;
+}
+
 }  // namespace
 
 EchoRemover* EchoRemover::Create(const EchoCanceller3Config& config,
diff --git a/modules/audio_processing/aec3/nearend_detector.h b/modules/audio_processing/aec3/nearend_detector.h
index 0d8a06b2cd43d1e9ea7f140d6d2f033f58430d1f..9fd6aafce73829f8383172a72bea119b3de06f4b 100644
--- a/modules/audio_processing/aec3/nearend_detector.h
+++ b/modules/audio_processing/aec3/nearend_detector.h
@@ -34,7 +34,8 @@ class NearendDetector {
           residual_echo_spectrum,
       rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>>
           comfort_noise_spectrum,
-      bool initial_state) = 0;
+      bool initial_state,
+      bool DTD) = 0;
 };
 
 }  // namespace webrtc
diff --git a/modules/audio_processing/aec3/subband_nearend_detector.cc b/modules/audio_processing/aec3/subband_nearend_detector.cc
index 2aa400c3af7ef0dcad95edcd934e21a0c762091d..6e308647f5a434fbcdd23a4e1ee5cf69e1551efc 100644
--- a/modules/audio_processing/aec3/subband_nearend_detector.cc
+++ b/modules/audio_processing/aec3/subband_nearend_detector.cc
@@ -33,7 +33,8 @@ void SubbandNearendDetector::Update(
         residual_echo_spectrum,
     rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>>
         comfort_noise_spectrum,
-    bool initial_state) {
+    bool initial_state,
+    bool DTD) {
   nearend_state_ = false;
   for (size_t ch = 0; ch < num_capture_channels_; ++ch) {
     const std::array<float, kFftLengthBy2Plus1>& noise =
@@ -64,7 +65,7 @@ void SubbandNearendDetector::Update(
         nearend_state_ ||
         (nearend_power_subband1 <
              config_.nearend_threshold * nearend_power_subband2 &&
-         (nearend_power_subband1 > config_.snr_threshold * noise_power));
+         (nearend_power_subband1 > config_.snr_threshold * noise_power)) || DTD;
   }
 }
 }  // namespace webrtc
diff --git a/modules/audio_processing/aec3/subband_nearend_detector.h b/modules/audio_processing/aec3/subband_nearend_detector.h
index 8357edb65fe43cc2fff1db3fa962867875515c1f..d922e62993ab59012183f6f6834092278dd33258 100644
--- a/modules/audio_processing/aec3/subband_nearend_detector.h
+++ b/modules/audio_processing/aec3/subband_nearend_detector.h
@@ -1,3 +1,4 @@
+
 /*
  *  Copyright (c) 2019 The WebRTC project authors. All Rights Reserved.
  *
@@ -36,7 +37,8 @@ class SubbandNearendDetector : public NearendDetector {
                   residual_echo_spectrum,
               rtc::ArrayView<const std::array<float, kFftLengthBy2Plus1>>
                   comfort_noise_spectrum,
-              bool initial_state) override;
+              bool initial_state,
+              bool DTD) override;
 
  private:
   const EchoCanceller3Config::Suppressor::SubbandNearendDetection config_;
diff --git a/modules/audio_processing/aec3/suppression_gain.cc b/modules/audio_processing/aec3/suppression_gain.cc
index 037dabaabe6866ddc2e77353289c176d024ce88c..b77be9a49aaa4d38e5859d409a323c2cb152850f 100644
--- a/modules/audio_processing/aec3/suppression_gain.cc
+++ b/modules/audio_processing/aec3/suppression_gain.cc
@@ -374,7 +374,8 @@ void SuppressionGain::GetGain(
     const Block& render,
     bool clock_drift,
     float* high_bands_gain,
-    std::array<float, kFftLengthBy2Plus1>* low_band_gain) {
+    std::array<float, kFftLengthBy2Plus1>* low_band_gain,
+    bool DTD) {
   RTC_DCHECK(high_bands_gain);
   RTC_DCHECK(low_band_gain);
 
@@ -385,7 +386,7 @@ void SuppressionGain::GetGain(
 
   // Update the nearend state selection.
   dominant_nearend_detector_->Update(nearend_spectrum, echo,
-                                     comfort_noise_spectrum, initial_state_);
+                                     comfort_noise_spectrum, initial_state_, DTD);
 
   // Compute gain for the lower band.
   bool low_noise_render = low_render_detector_.Detect(render);
diff --git a/modules/audio_processing/aec3/suppression_gain.h b/modules/audio_processing/aec3/suppression_gain.h
index c19ddd7e306f26119f8d524fb062b96f93b286c7..c6b57efed3f032fb6d189f8c2ec0841079229a09 100644
--- a/modules/audio_processing/aec3/suppression_gain.h
+++ b/modules/audio_processing/aec3/suppression_gain.h
@@ -55,7 +55,8 @@ class SuppressionGain {
       const Block& render,
       bool clock_drift,
       float* high_bands_gain,
-      std::array<float, kFftLengthBy2Plus1>* low_band_gain);
+      std::array<float, kFftLengthBy2Plus1>* low_band_gain,
+      bool DTD);
 
   bool IsDominantNearend() {
     return dominant_nearend_detector_->IsNearendState();
