From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: lorne <lorne.shi@gmail.com>
Date: Fri, 22 Dec 2023 14:34:50 +0800
Subject: Support and enable rsfecopus
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

音频编码支持rsfecopus, 并且设置为默认,代替原来的opus

diff --git a/BUILD.gn b/BUILD.gn
index 7e8325e306bebe5ca024ad7ab77c64a84ef8b692..35f067085b49c385ecd70b728fed8bc459973cd8 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -322,6 +322,10 @@ config("common_config") {
     defines += [ "WEBRTC_USE_H264" ]
   }
 
+  if (rtc_enable_rsfecopus) {
+    defines += [ "WEBRTC_ENABLE_RSFECOPUS" ]
+  }
+
   if (rtc_use_absl_mutex) {
     defines += [ "WEBRTC_ABSL_MUTEX" ]
   }
diff --git a/api/audio_codecs/opus/audio_decoder_opus.cc b/api/audio_codecs/opus/audio_decoder_opus.cc
index efc9a73546efe75d00d1d0f0ead2969135406eb5..40f1589e269fc302febe137f6c0491ad517ae7a3 100644
--- a/api/audio_codecs/opus/audio_decoder_opus.cc
+++ b/api/audio_codecs/opus/audio_decoder_opus.cc
@@ -46,7 +46,8 @@ absl::optional<AudioDecoderOpus::Config> AudioDecoderOpus::SdpToConfig(
     }
     return 1;  // Default to mono.
   }();
-  if (absl::EqualsIgnoreCase(format.name, "opus") &&
+  if ((absl::EqualsIgnoreCase(format.name, "opus") ||
+       absl::EqualsIgnoreCase(format.name, "rsfecopus")) &&
       format.clockrate_hz == 48000 && format.num_channels == 2 &&
       num_channels) {
     Config config;
@@ -66,6 +67,10 @@ void AudioDecoderOpus::AppendSupportedDecoders(
   AudioCodecInfo opus_info{48000, 1, 64000, 6000, 510000};
   opus_info.allow_comfort_noise = false;
   opus_info.supports_network_adaption = true;
+  SdpAudioFormat newOpus_format(
+      {"rsfecopus", 48000, 2, {{"minptime", "10"}, {"useinbandfec", "1"}}});
+  specs->push_back({std::move(newOpus_format), opus_info});
+
   SdpAudioFormat opus_format(
       {"opus", 48000, 2, {{"minptime", "10"}, {"useinbandfec", "1"}}});
   specs->push_back({std::move(opus_format), opus_info});
diff --git a/audio/channel_receive.cc b/audio/channel_receive.cc
index f5d214f672a63410c77c5799127e35b4c7da337e..b15299818eeba7b9243694240ee401fa2d7ffb94 100644
--- a/audio/channel_receive.cc
+++ b/audio/channel_receive.cc
@@ -42,6 +42,9 @@
 #include "modules/rtp_rtcp/source/rtp_packet_received.h"
 #include "modules/rtp_rtcp/source/rtp_rtcp_config.h"
 #include "modules/rtp_rtcp/source/rtp_rtcp_impl2.h"
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+#include "modules/rtp_rtcp/source/rs_fec.h"
+#endif // WEBRTC_ENABLE_RSFECOPUS
 #include "rtc_base/checks.h"
 #include "rtc_base/logging.h"
 #include "rtc_base/numerics/safe_minmax.h"
@@ -53,6 +56,7 @@
 #include "rtc_base/trace_event.h"
 #include "system_wrappers/include/metrics.h"
 #include "system_wrappers/include/ntp_time.h"
+#include "media/base/rtp_utils.h"
 
 namespace webrtc {
 namespace voe {
@@ -312,6 +316,12 @@ class ChannelReceive : public ChannelReceiveInterface,
   mutable Mutex rtcp_counter_mutex_;
   RtcpPacketTypeCounter rtcp_packet_type_counter_
       RTC_GUARDED_BY(rtcp_counter_mutex_);
+
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+  //Reed-Solomon
+  std::unique_ptr<RsFecDecoder> rs_decoder_;
+  // int plr_;
+#endif // WEBRTC_ENABLE_RSFECOPUS
 };
 
 void ChannelReceive::OnReceivedPayloadData(
@@ -593,6 +603,12 @@ ChannelReceive::ChannelReceive(
 
   // Ensure that RTCP is enabled for the created channel.
   rtp_rtcp_->SetRTCPStatus(RtcpMode::kCompound);
+
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+  //Reed-Solomon
+  rs_decoder_.reset(new RsFecDecoder());
+  rs_decoder_->Init();
+#endif // WEBRTC_ENABLE_RSFECOPUS
 }
 
 ChannelReceive::~ChannelReceive() {
@@ -665,16 +681,57 @@ void ChannelReceive::OnRtpPacket(const RtpPacketReceived& packet) {
   RTPHeader header;
   packet_copy.GetHeader(&header);
 
-  // Interpolates absolute capture timestamp RTP header extension.
-  header.extension.absolute_capture_time =
-      absolute_capture_time_interpolator_.OnReceivePacket(
-          AbsoluteCaptureTimeInterpolator::GetSource(header.ssrc,
-                                                     header.arrOfCSRCs),
-          header.timestamp,
-          rtc::saturated_cast<uint32_t>(packet_copy.payload_type_frequency()),
-          header.extension.absolute_capture_time);
+  if (packet.size() <= header.headerLength + header.paddingLength) {
+    RTC_LOG(LS_WARNING) << "remove a padding packet";
+    return;
+  }
+
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+  if(header.payloadType == RS_FEC_PAYLOAD_TYPE)
+  {
+
+    RTPHeader header_tmp = header;
+    int hlen = header.headerLength+header.paddingLength;
+    size_t length = packet.size();
+    int buf_size = cricket::kMaxRtpPacketLen;
+    std::unique_ptr<uint8_t> decoded_buf (new uint8_t[buf_size]);
+    uint8_t pt;
+    int decoded_size;
+    memcpy(decoded_buf.get(),packet.data(),hlen);
+
+    decoded_size = rs_decoder_->Decode(packet.data()+hlen, length - hlen,
+          header.sequenceNumber , header.timestamp, decoded_buf.get()+hlen, buf_size-hlen, pt);
+
+    if(decoded_size>1)
+    {
+      header_tmp.payloadType = pt;
+
+      ReceivePacket(decoded_buf.get(), hlen+decoded_size, header_tmp);
+    }
+    while((decoded_size = rs_decoder_->GetRecoveryData(decoded_buf.get()+hlen, buf_size-hlen,
+        header_tmp.sequenceNumber , header_tmp.timestamp, header_tmp.payloadType))>0)
+    {
+
+      RTC_DLOG(LS_VERBOSE)<< "Channel rs_decoder_::GetRecoveryData():sn="<< header_tmp.sequenceNumber<< ",ts="
+              << header_tmp.timestamp<< ",pt="<<(int)header_tmp.payloadType << ",size="<<decoded_size;
 
-  ReceivePacket(packet_copy.data(), packet_copy.size(), header);
+      ReceivePacket(decoded_buf.get(), hlen+decoded_size, header_tmp);
+    }
+  }
+  else
+#endif // WEBRTC_ENABLE_RSFECOPUS
+  {
+    // Interpolates absolute capture timestamp RTP header extension.
+    header.extension.absolute_capture_time =
+        absolute_capture_time_interpolator_.OnReceivePacket(
+            AbsoluteCaptureTimeInterpolator::GetSource(header.ssrc,
+                                                      header.arrOfCSRCs),
+            header.timestamp,
+            rtc::saturated_cast<uint32_t>(packet_copy.payload_type_frequency()),
+            header.extension.absolute_capture_time);
+
+    ReceivePacket(packet_copy.data(), packet_copy.size(), header);
+  }
 }
 
 void ChannelReceive::ReceivePacket(const uint8_t* packet,
diff --git a/audio/channel_send.cc b/audio/channel_send.cc
index 08dd74591d8d5ea043b5c9955c92803e287c3d47..69edda24e8636602b547a20ec77dba4501f05925 100644
--- a/audio/channel_send.cc
+++ b/audio/channel_send.cc
@@ -31,6 +31,9 @@
 #include "modules/audio_processing/rms_level.h"
 #include "modules/pacing/packet_router.h"
 #include "modules/rtp_rtcp/source/rtp_rtcp_impl2.h"
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+#include "modules/rtp_rtcp/source/rs_fec.h"
+#endif // WEBRTC_ENABLE_RSFECOPUS
 #include "rtc_base/checks.h"
 #include "rtc_base/event.h"
 #include "rtc_base/logging.h"
@@ -550,6 +553,59 @@ void ChannelSend::OnReportBlockDataUpdated(ReportBlockData report_block) {
   float packet_loss_rate = report_block.fraction_lost();
   CallEncoder([&](AudioEncoder* encoder) {
     encoder->OnReceivedUplinkPacketLossFraction(packet_loss_rate);
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+    uint32_t jitter = report_block.jitter();
+    uint32_t downlink_plr = report_block.cumulative_lost() & 0x7;
+    if (rtp_sender_audio_->GetRsStatus()) {
+      int n = 12;
+      float plr = packet_loss_rate;
+      float dl_plr = 0;
+      int audio_bitrate = 0;
+
+      switch (downlink_plr) {
+        case 1:
+          dl_plr = 0.1f;break;
+        case 2:
+          dl_plr = 0.15f;break;
+        case 3:
+          dl_plr = 0.45f;break;
+        case 4:
+          dl_plr = 0.6f;break;
+        case 5:
+          dl_plr = 0.7f;break;
+        default:
+          break;
+      }
+
+      float jitter_ms = 1000.0f * jitter / encoder->SampleRateHz();
+      float jitter_plr = plr;
+      if (jitter_ms > 50) {
+        jitter_plr = plr + 0.002f * (jitter_ms - 50.0f) * (1.0f - plr);
+      }
+      jitter_plr += dl_plr;
+
+      if (jitter_plr < 0.1f) {
+        n = 8 + jitter_plr * 40;
+        audio_bitrate = 20000;
+      } else if(jitter_plr < 0.18f) {
+        n = 12;
+        audio_bitrate = 18000;
+      } else if(jitter_plr < 0.5f) {
+        n = 24;
+        audio_bitrate = 16000;
+      } else if(jitter_plr < 0.65f) {
+        n = 27;
+        audio_bitrate = 14000;
+      } else if(plr >= 0.65f) {
+        n = 30;
+        audio_bitrate = 12000;
+      } else {
+        n = 30;
+      }
+      rtp_sender_audio_->SetRsPara(n);
+      encoder->OnReceivedTargetAudioBitrate(audio_bitrate);
+    }
+#endif // WEBRTC_ENABLE_RSFECOPUS
   });
 }
 
diff --git a/media/base/media_constants.cc b/media/base/media_constants.cc
index 2af0295a5a05e45416abcba9ebfb656e73dc7119..e090b5ff1c4fb8328a60773d7788da8e7b2370c4 100644
--- a/media/base/media_constants.cc
+++ b/media/base/media_constants.cc
@@ -43,6 +43,7 @@ const char kCodecParamAssociatedCodecName[] = "acn";
 // are treated as having the empty string as key.
 const char kCodecParamNotInNameValueFormat[] = "";
 
+const char kRsFecOpusCodecName[] = "rsfecopus";
 const char kOpusCodecName[] = "opus";
 const char kL16CodecName[] = "L16";
 const char kG722CodecName[] = "G722";
diff --git a/media/base/media_constants.h b/media/base/media_constants.h
index 877cc7a296e32128364f630fba136df9cd6e2f3e..f19f3b374bbb6ac4766bf459c1f928aedb9cd53e 100644
--- a/media/base/media_constants.h
+++ b/media/base/media_constants.h
@@ -44,6 +44,7 @@ extern const char kCodecParamAssociatedPayloadType[];
 extern const char kCodecParamAssociatedCodecName[];
 extern const char kCodecParamNotInNameValueFormat[];
 
+extern const char kRsFecOpusCodecName[];
 extern const char kOpusCodecName[];
 extern const char kL16CodecName[];
 extern const char kG722CodecName[];
diff --git a/media/engine/payload_type_mapper.cc b/media/engine/payload_type_mapper.cc
index bd86453b1ca7c4d3dfeffcda5ac4807c4339ddc7..b21e902e7b1e576b416d66b08a4cae10d38656fc 100644
--- a/media/engine/payload_type_mapper.cc
+++ b/media/engine/payload_type_mapper.cc
@@ -65,6 +65,11 @@ PayloadTypeMapper::PayloadTypeMapper()
            {{kIlbcCodecName, 8000, 1}, 102},
            {{kCnCodecName, 16000, 1}, 105},
            {{kCnCodecName, 32000, 1}, 106},
+           {{kRsFecOpusCodecName,
+             48000,
+             2,
+             {{"minptime", "10"}, {"useinbandfec", "0"}}},
+            115},
            {{kOpusCodecName,
              48000,
              2,
diff --git a/modules/audio_coding/codecs/opus/audio_encoder_opus.cc b/modules/audio_coding/codecs/opus/audio_encoder_opus.cc
index 51b0fcd492599ed088f1017bf16e9524653ef389..094fba4bb04d5f0f93591cddc58013a71e89e1bb 100644
--- a/modules/audio_coding/codecs/opus/audio_encoder_opus.cc
+++ b/modules/audio_coding/codecs/opus/audio_encoder_opus.cc
@@ -207,6 +207,13 @@ int GetMultipliedBitrate(int bitrate, const std::vector<float>& multipliers) {
 
 void AudioEncoderOpusImpl::AppendSupportedEncoders(
     std::vector<AudioCodecSpec>* specs) {
+  const SdpAudioFormat newFmt = {"rsfecopus",
+                              kRtpTimestampRateHz,
+                              2,
+                              {{"minptime", "10"}, {"useinbandfec", "0"}}};
+  const AudioCodecInfo newInfo = QueryAudioEncoder(*SdpToConfig(newFmt));
+  specs->push_back({newFmt, newInfo});
+
   const SdpAudioFormat fmt = {"opus",
                               kRtpTimestampRateHz,
                               2,
@@ -239,7 +246,8 @@ std::unique_ptr<AudioEncoder> AudioEncoderOpusImpl::MakeAudioEncoder(
 
 absl::optional<AudioEncoderOpusConfig> AudioEncoderOpusImpl::SdpToConfig(
     const SdpAudioFormat& format) {
-  if (!absl::EqualsIgnoreCase(format.name, "opus") ||
+  if (!(absl::EqualsIgnoreCase(format.name, "opus") ||
+        absl::EqualsIgnoreCase(format.name, "rsfecopus")) ||
       format.clockrate_hz != kRtpTimestampRateHz || format.num_channels != 2) {
     return absl::nullopt;
   }
diff --git a/modules/rtp_rtcp/BUILD.gn b/modules/rtp_rtcp/BUILD.gn
index 0fc9931f3985079c92440e5a761fc680a010cb6f..1bda72cced85d066af04e65497739d6db12d7cb6 100644
--- a/modules/rtp_rtcp/BUILD.gn
+++ b/modules/rtp_rtcp/BUILD.gn
@@ -258,6 +258,13 @@ rtc_library("rtp_rtcp") {
     "source/video_rtp_depacketizer_vp9.h",
   ]
 
+  if (rtc_enable_rsfecopus) {
+    sources += [
+      "source/rs_fec.cc",
+      "source/rs_fec.h",
+    ]
+  }
+
   if (rtc_enable_bwe_test_logging) {
     defines = [ "BWE_TEST_LOGGING_COMPILE_TIME_ENABLE=1" ]
   } else {
diff --git a/modules/rtp_rtcp/source/rs_fec.cc b/modules/rtp_rtcp/source/rs_fec.cc
new file mode 100644
index 0000000000000000000000000000000000000000..e8460db55f8e32e7f376f4e237937e55cffb7da1
--- /dev/null
+++ b/modules/rtp_rtcp/source/rs_fec.cc
@@ -0,0 +1,1541 @@
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+// #include <stdint.h>
+// #include <iostream>
+//using namespace std;
+// #include "webrtc/typedefs.h"
+#include "rtc_base/logging.h"
+#include "rs_fec.h"
+
+#if __cplusplus > 199711L
+#define register      // Deprecated in C++11.
+#endif  // #if __cplusplus > 199711L
+
+
+#define GF_BITS  8
+#define	GF_SIZE ((1 << GF_BITS) - 1)
+
+
+typedef unsigned char gf;
+
+static gf gf_exp[2*GF_SIZE];	/* index->poly form conversion table	*/
+static int gf_log[GF_SIZE + 1];	/* Poly->index form conversion table	*/
+static gf inverse[GF_SIZE+1];	/* inverse of field elem.		*/
+static gf gf_mul_table[GF_SIZE + 1][GF_SIZE + 1];
+
+#define SWAP(a,b,t) {t tmp; tmp=a; a=b; b=tmp;}
+
+//static gf gf_mul_table[GF_SIZE + 1][GF_SIZE + 1];
+
+#define gf_mul(x,y) gf_mul_table[x][y]
+
+#define USE_GF_MULC register gf * __gf_mulc_
+#define GF_MULC0(c) __gf_mulc_ = gf_mul_table[c]
+#define GF_ADDMULC(dst, x) dst ^= __gf_mulc_[x]
+
+#define addmul(dst, src, c, sz) \
+    if (c != 0) addmul1(dst, src, c, sz)
+
+
+static inline gf modnn(int x)
+{
+    while (x >= GF_SIZE) {
+	x -= GF_SIZE;
+	x = (x >> GF_BITS) + (x & GF_SIZE);
+    }
+    return x;
+}
+
+#define UNROLL 16 /* 1, 4, 8, 16 */
+static void addmul1(gf *dst1, gf *src1, gf c, int sz)
+{
+    USE_GF_MULC ;
+    register gf *dst = dst1, *src = src1 ;
+    gf *lim = &dst[sz - UNROLL + 1] ;
+
+    GF_MULC0(c) ;
+
+#if (UNROLL > 1) /* unrolling by 8/16 is quite effective on the pentium */
+    for (; dst < lim ; dst += UNROLL, src += UNROLL ) {
+	GF_ADDMULC( dst[0] , src[0] );
+	GF_ADDMULC( dst[1] , src[1] );
+	GF_ADDMULC( dst[2] , src[2] );
+	GF_ADDMULC( dst[3] , src[3] );
+#if (UNROLL > 4)
+	GF_ADDMULC( dst[4] , src[4] );
+	GF_ADDMULC( dst[5] , src[5] );
+	GF_ADDMULC( dst[6] , src[6] );
+	GF_ADDMULC( dst[7] , src[7] );
+#endif
+#if (UNROLL > 8)
+	GF_ADDMULC( dst[8] , src[8] );
+	GF_ADDMULC( dst[9] , src[9] );
+	GF_ADDMULC( dst[10] , src[10] );
+	GF_ADDMULC( dst[11] , src[11] );
+	GF_ADDMULC( dst[12] , src[12] );
+	GF_ADDMULC( dst[13] , src[13] );
+	GF_ADDMULC( dst[14] , src[14] );
+	GF_ADDMULC( dst[15] , src[15] );
+#endif
+    }
+#endif
+    lim += UNROLL - 1 ;
+    for (; dst < lim; dst++, src++ )		/* final components */
+	GF_ADDMULC( *dst , *src );
+}
+
+
+/*
+ * initialize the data structures used for computations in GF.
+ */
+static void generate_gf(void)
+{
+    int i;
+    gf mask;
+    char Pp[] =  "101110001";
+
+    mask = 1;	/* x ** 0 = 1 */
+    gf_exp[GF_BITS] = 0; /* will be updated at the end of the 1st loop */
+    /*
+     * first, generate the (polynomial representation of) powers of \alpha,
+     * which are stored in gf_exp[i] = \alpha ** i .
+     * At the same time build gf_log[gf_exp[i]] = i .
+     * The first GF_BITS powers are simply bits shifted to the left.
+     */
+    for (i = 0; i < GF_BITS; i++, mask <<= 1 ) {
+	gf_exp[i] = mask;
+	gf_log[gf_exp[i]] = i;
+	/*
+	 * If Pp[i] == 1 then \alpha ** i occurs in poly-repr
+	 * gf_exp[GF_BITS] = \alpha ** GF_BITS
+	 */
+	if ( Pp[i] == '1' )
+	    gf_exp[GF_BITS] ^= mask;
+    }
+    /*
+     * now gf_exp[GF_BITS] = \alpha ** GF_BITS is complete, so can als
+     * compute its inverse.
+     */
+    gf_log[gf_exp[GF_BITS]] = GF_BITS;
+    /*
+     * Poly-repr of \alpha ** (i+1) is given by poly-repr of
+     * \alpha ** i shifted left one-bit and accounting for any
+     * \alpha ** GF_BITS term that may occur when poly-repr of
+     * \alpha ** i is shifted.
+     */
+    mask = 1 << (GF_BITS - 1 ) ;
+    for (i = GF_BITS + 1; i < GF_SIZE; i++) {
+	if (gf_exp[i - 1] >= mask)
+	    gf_exp[i] = gf_exp[GF_BITS] ^ ((gf_exp[i - 1] ^ mask) << 1);
+	else
+	    gf_exp[i] = gf_exp[i - 1] << 1;
+	gf_log[gf_exp[i]] = i;
+    }
+    /*
+     * log(0) is not defined, so use a special value
+     */
+    gf_log[0] =	GF_SIZE ;
+    /* set the extended gf_exp values for fast multiply */
+    for (i = 0 ; i < GF_SIZE ; i++)
+	gf_exp[i + GF_SIZE] = gf_exp[i] ;
+
+    /*
+     * again special cases. 0 has no inverse. This used to
+     * be initialized to GF_SIZE, but it should make no difference
+     * since noone is supposed to read from here.
+     */
+    inverse[0] = 0 ;
+    inverse[1] = 1;
+    for (i=2; i<=GF_SIZE; i++)
+	inverse[i] = gf_exp[GF_SIZE-gf_log[i]];
+}
+
+static void init_mul_table()
+{
+    int i, j;
+    for (i=0; i< GF_SIZE+1; i++)
+	for (j=0; j< GF_SIZE+1; j++)
+	    gf_mul_table[i][j] = gf_exp[modnn(gf_log[i] + gf_log[j]) ] ;
+
+    for (j=0; j< GF_SIZE+1; j++)
+	    gf_mul_table[0][j] = gf_mul_table[j][0] = 0;
+}
+
+static int fec_initialized = 0 ;
+static void init_fec()
+{
+	if(fec_initialized == 0)
+	{
+		fec_initialized = 1;
+
+	    generate_gf();
+
+	    init_mul_table();
+	}
+
+}
+
+static int invert_vdm(gf *src, int k)
+{
+    int i, j, row, col ;
+    gf *b, *c, *p;
+    gf t, xx ;
+
+    if (k == 1) 	/* degenerate case, matrix must be p^0 = 1 */
+	return 0 ;
+    /*
+     * c holds the coefficient of P(x) = Prod (x - p_i), i=0..k-1
+     * b holds the coefficient for the matrix inversion
+     */
+    c = new gf[k];
+    b = new gf[k];
+
+    p = new gf[k];
+
+    for ( j=1, i = 0 ; i < k ; i++, j+=k )
+    {
+		c[i] = 0 ;
+		p[i] = src[j] ;    /* p[i] */
+    }
+    /*
+     * construct coeffs. recursively. We know c[k] = 1 (implicit)
+     * and start P_0 = x - p_0, then at each stage multiply by
+     * x - p_i generating P_i = x P_{i-1} - p_i P_{i-1}
+     * After k steps we are done.
+     */
+    c[k-1] = p[0] ;	/* really -p(0), but x = -x in GF(2^m) */
+    for (i = 1 ; i < k ; i++ )
+    {
+		gf p_i = p[i] ; /* see above comment */
+		for (j = k-1  - ( i - 1 ) ; j < k-1 ; j++ )
+		    c[j] ^= gf_mul( p_i, c[j+1] ) ;
+
+		c[k-1] ^= p_i ;
+    }
+
+    for (row = 0 ; row < k ; row++ ) {
+	/*
+	 * synthetic division etc.
+	 */
+	xx = p[row] ;
+	t = 1 ;
+	b[k-1] = 1 ; /* this is in fact c[k] */
+	for (i = k-2 ; i >= 0 ; i-- ) {
+	    b[i] = c[i+1] ^ gf_mul(xx, b[i+1]) ;
+	    t = gf_mul(xx, t) ^ b[i] ;
+	}
+	for (col = 0 ; col < k ; col++ )
+	    src[col*k + row] = gf_mul(inverse[t], b[col] );
+    }
+
+    delete [] c;
+    delete [] b;
+    delete [] p;
+    return 0 ;
+}
+
+static void matmul(gf *a, gf *b, gf *c, int n, int k, int m)
+{
+    int row, col, i ;
+
+    for (row = 0; row < n ; row++) {
+	for (col = 0; col < m ; col++) {
+	    gf *pa = &a[ row * k ];
+	    gf *pb = &b[ col ];
+	    gf acc = 0 ;
+	    for (i = 0; i < k ; i++, pa++, pb += m )
+		acc ^= gf_mul( *pa, *pb ) ;
+	    c[ row * m + col ] = acc ;
+	}
+    }
+}
+
+static gf *creat_encode_mat(int n, int k)
+{
+    int row, col ;
+    gf *p, *tmp_m, *em ;
+
+    em = new gf[n*k];
+
+    tmp_m = new gf[n*k];
+    /*
+     * fill the matrix with powers of field elements, starting from 0.
+     * The first row is special, cannot be computed with exp. table.
+     */
+    tmp_m[0] = 1 ;
+    for (col = 1; col < k ; col++)
+	tmp_m[col] = 0 ;
+    for (p = tmp_m + k, row = 0; row < n-1 ; row++, p += k) {
+	for ( col = 0 ; col < k ; col ++ )
+	    p[col] = gf_exp[modnn(row*col)];
+    }
+
+    /*
+     * quick code to build systematic matrix: invert the top
+     * k*k vandermonde matrix, multiply right the bottom n-k rows
+     * by the inverse, and construct the identity matrix at the top.
+     */
+
+    invert_vdm(tmp_m, k); /* much faster than invert_mat */
+    matmul(tmp_m + k*k, tmp_m, em + k*k, n - k, k, k);
+    /*
+     * the upper matrix is I so do not bother with a slow multiply
+     */
+    memset(em, 0,k*k*sizeof(gf) );
+    for (p = em, col = 0 ; col < k ; col++, p += k+1 )
+    {
+		*p = 1 ;
+    }
+    delete [] tmp_m;
+
+    return em;
+}
+
+
+
+
+/*
+ * fec_encode accepts as input pointers to n data packets of size sz,
+ * and produces as output a packet pointed to by fec, computed
+ * with index "index".
+ */
+static void fec_encode(gf *code, int n, int k, gf *src[], gf *fec, int index, int sz)
+{
+    int i ;
+    gf *p ;
+
+
+
+    if (index < k)
+    {
+        memcpy(fec, src[index], sz*sizeof(gf) ) ;
+    }
+    else if (index < n)
+    {
+			p = &(code[index*k]);
+			memset(fec, 0, sz*sizeof(gf));
+			for (i = 0; i < k ; i++)
+			    addmul(fec, src[i], p[i], sz ) ;
+    } else
+	fprintf(stderr, "Invalid index %d (max %d)\n",
+	    index, n - 1 );
+}
+
+
+static int invert_mat(gf *src, int k)
+{
+    gf c, *p ;
+    int irow, icol, row, col, i, ix ;
+
+    int error = 1 ;
+
+
+    int *indxc = new int[k];
+    int *indxr = new int[k];
+    int *ipiv = new int[k];
+    gf *id_row = new gf[k];
+
+
+    memset(id_row, 0, k*sizeof(gf));
+
+    /*
+     * ipiv marks elements already used as pivots.
+     */
+    for (i = 0; i < k ; i++)
+	ipiv[i] = 0 ;
+
+    for (col = 0; col < k ; col++) {
+	gf *pivot_row ;
+	/*
+	 * Zeroing column 'col', look for a non-zero element.
+	 * First try on the diagonal, if it fails, look elsewhere.
+	 */
+	irow = icol = -1 ;
+	if (ipiv[col] != 1 && src[col*k + col] != 0)
+	{
+	    irow = col ;
+	    icol = col ;
+	}
+	else
+	{
+		for (row = 0 ; row < k ; row++)
+		{
+		    if (ipiv[row] != 1)
+		    {
+				for (ix = 0 ; ix < k ; ix++)
+				{
+				    if (ipiv[ix] == 0)
+				    {
+						if (src[row*k + ix] != 0)
+						{
+						    irow = row ;
+						    icol = ix ;
+						    break ;
+						}
+				    }
+				    else if (ipiv[ix] > 1)
+				    {
+						fprintf(stderr, "singular matrix\n");
+						goto fail ;
+				    }
+				}
+		    }
+		}
+		if (icol == -1) {
+		    fprintf(stderr, "XXX pivot not found!\n");
+		    goto fail ;
+		}
+	}
+
+	++(ipiv[icol]) ;
+	/*
+	 * swap rows irow and icol, so afterwards the diagonal
+	 * element will be correct. Rarely done, not worth
+	 * optimizing.
+	 */
+	if (irow != icol) {
+	    for (ix = 0 ; ix < k ; ix++ ) {
+		SWAP( src[irow*k + ix], src[icol*k + ix], gf) ;
+	    }
+	}
+	indxr[col] = irow ;
+	indxc[col] = icol ;
+	pivot_row = &src[icol*k] ;
+	c = pivot_row[icol] ;
+	if (c == 0) {
+	    fprintf(stderr, "singular matrix 2\n");
+	    goto fail ;
+	}
+	if (c != 1 ) { /* otherwhise this is a NOP */
+	    /*
+	     * this is done often , but optimizing is not so
+	     * fruitful, at least in the obvious ways (unrolling)
+	     */
+
+	    c = inverse[ c ] ;
+	    pivot_row[icol] = 1 ;
+	    for (ix = 0 ; ix < k ; ix++ )
+		pivot_row[ix] = gf_mul(c, pivot_row[ix] );
+	}
+	/*
+	 * from all rows, remove multiples of the selected row
+	 * to zero the relevant entry (in fact, the entry is not zero
+	 * because we know it must be zero).
+	 * (Here, if we know that the pivot_row is the identity,
+	 * we can optimize the addmul).
+	 */
+	id_row[icol] = 1;
+	if (memcmp(pivot_row, id_row, k*sizeof(gf)) != 0) {
+	    for (p = src, ix = 0 ; ix < k ; ix++, p += k ) {
+		if (ix != icol) {
+		    c = p[icol] ;
+		    p[icol] = 0 ;
+		    addmul(p, pivot_row, c, k );
+		}
+	    }
+	}
+	id_row[icol] = 0;
+    } /* done all columns */
+    for (col = k-1 ; col >= 0 ; col-- ) {
+	if (indxr[col] <0 || indxr[col] >= k)
+	    fprintf(stderr, "AARGH, indxr[col] %d\n", indxr[col]);
+	else if (indxc[col] <0 || indxc[col] >= k)
+	    fprintf(stderr, "AARGH, indxc[col] %d\n", indxc[col]);
+	else
+	if (indxr[col] != indxc[col] ) {
+	    for (row = 0 ; row < k ; row++ ) {
+		SWAP( src[row*k + indxr[col]], src[row*k + indxc[col]], gf) ;
+	    }
+	}
+    }
+    error = 0 ;
+
+
+fail:
+    delete [] indxc;
+    delete [] indxr;
+    delete [] ipiv;
+    delete [] id_row;
+
+    return error ;
+}
+
+
+static int shuffle(gf *pkt[], int index[], int k)
+{
+    int i;
+
+    for ( i = 0 ; i < k ; )
+    {
+		if (index[i] >= k || index[i] == i)
+		{
+		    i++ ;
+		}
+		else
+		{
+		    /*
+		     * put pkt in the right position (first check for conflicts).
+		     */
+		    int c = index[i] ;
+
+		    if (index[c] == c)
+		    {
+				return 1;
+		    }
+		    SWAP(index[i], index[c], int) ;
+		    SWAP(pkt[i], pkt[c], gf *) ;
+		}
+    }
+
+    for ( i = 0 ; i < k ; i++ )
+    {
+		if (index[i] < k && index[i] != i)
+		{
+		    fprintf(stderr, "shuffle: after\n");
+		    for (i=0; i<k ; i++) fprintf(stderr, "%3d ", index[i]);
+		    fprintf(stderr, "\n");
+		    return 1 ;
+		}
+    }
+
+    return 0 ;
+}
+
+static gf *build_decode_matrix(gf *code, int n, int k, int index[])
+{
+    int i;
+    gf *p, *matrix;
+    matrix = new gf[k*k];
+
+    for (i = 0, p = matrix ; i < k ; i++, p += k )
+    {
+		if(index[i] < k)
+		{
+		    memset(p,0, k*sizeof(gf));
+		    p[i] = 1 ;
+		}
+		else if(index[i] < n )
+		{
+			{
+			    memcpy( p, &(code[index[i]*k]),  k*sizeof(gf) );
+			}
+		}
+		else
+		{
+		    delete [] matrix ;
+		    return NULL ;
+		}
+    }
+
+    if (invert_mat(matrix, k) != 0)
+    {
+		delete [] matrix ;
+		matrix = NULL ;
+    }
+
+    return matrix ;
+}
+
+
+static int fec_decode(gf *code, int n, int k, gf *pkt[], int index[], int sz)
+{
+    gf *m_dec ;
+    gf **new_pkt ;
+    int row, col ;
+
+    // cout <<"fec_decode n: "  << n <<", k: "  << k <<endl;
+
+    if (code == NULL)
+    {
+		return 1 ; /* error */
+    }
+
+    for (col = 0 ; col < k ; col++ )
+    {
+		if(pkt[col]==NULL)
+		{
+			return 1;
+		}
+	}
+
+    if (shuffle(pkt, index, k))
+    {
+		return 1 ;
+    }
+    m_dec = build_decode_matrix(code,n,k, index);
+
+    if (m_dec == NULL)
+    {
+		return 1 ; /* error */
+    }
+    /*
+     * do the actual decoding
+     */
+	new_pkt = new gf* [k];
+    for (row = 0 ; row < k ; row++ )
+    {
+		if (index[row] >= k)
+		{
+		    new_pkt[row] = new gf [sz];
+		    memset(new_pkt[row], 0, sz * sizeof(gf) ) ;
+		    for (col = 0 ; col < k ; col++ )
+		    {
+				addmul(new_pkt[row], pkt[col], m_dec[row*k + col], sz) ;
+			}
+		}
+    }
+    /*
+     * move pkts to their final destination
+     */
+    for (row = 0 ; row < k ; row++ )
+    {
+		if (index[row] >= k)
+		{
+		    memcpy(pkt[row], new_pkt[row],  sz*sizeof(gf));
+		    delete [] new_pkt[row];
+		}
+    }
+
+    delete [] new_pkt;
+    delete [] m_dec;
+
+    // cout <<"fec_decode end "<<endl;
+
+    return 0;
+}
+
+
+
+
+// static const int kSamplerate[4] = {16000,32000,48000,441000};
+// static const int kFrameSize[4]  = {20 ,40,60,80};
+
+
+RsFecEncoder::RsFecEncoder()
+{
+	m_k_ = FEC_K;
+	src_pkg_cnt_ = 0;
+    fec_pkg_idx_ = m_k_;
+    max_size_ = 0;
+    // sample_rate_id_ = 0;
+    // frame_size_id_ = 0;
+    // need_set_n_ = false;
+	n_to_set_ = FEC_K + 1;
+	m_n_ = FEC_K + 1;
+
+	fec_flag_ = false;
+
+    int i;
+    for(i=0;i<MAX_FEC_N;i++)
+    {
+		pkg_list_[i] = NULL;
+    }
+
+    for(i=0;i<MAX_FEC_N-FEC_K;i++)
+    {
+		enc_mat_[i] = NULL;
+    }
+}
+
+RsFecEncoder::~RsFecEncoder()
+{
+	int i;
+	for(i=0;i<MAX_FEC_N;i++)
+    {
+		if(pkg_list_[i] != NULL)
+		{
+			delete [] pkg_list_[i];
+		}
+    }
+
+    for(i=0;i<MAX_FEC_N-FEC_K;i++)
+    {
+		if(enc_mat_[i] != NULL)
+		{
+			delete [] enc_mat_[i];
+		}
+    }
+
+}
+
+int RsFecEncoder::Init(uint8_t n,int sample_rate)
+{
+	if(n<=MAX_FEC_N  && n>m_k_)
+	{
+		m_n_ = n;
+		//m_k_ = k;
+	}
+	else
+	{
+		m_n_ = FEC_K + 1;
+		//m_k_ = 4;
+	}
+
+	n_to_set_ = m_n_;
+	// src_pkg_cnt_ = 0;
+ //    fec_pkg_idx_ = m_k_;
+
+    init_fec();
+ //    if(enc_mat_[n-m_k_-1] == NULL)
+	// {
+	// 	enc_mat_[n-m_k_-1] = creat_encode_mat(m_n_,m_k_);
+	// }
+
+	SetSampleRate(sample_rate);
+	//SetFrameSize(frame_size);
+    return 0;
+}
+
+
+uint8_t* RsFecEncoder::GetEncodeMat(int n)
+{
+	if(n<=FEC_K)
+	{
+		return NULL;
+	}
+
+	if(enc_mat_[n-FEC_K-1] == NULL)
+	{
+		enc_mat_[n-FEC_K-1] = creat_encode_mat(n,FEC_K);
+	}
+
+	return enc_mat_[n-FEC_K-1];
+}
+
+
+bool RsFecEncoder::IsNeedSendRedPkg()
+{
+	if(m_n_ > 2*m_k_)
+	{
+		if(fec_pkg_idx_ < m_k_ || fec_pkg_idx_ >= m_n_ - m_k_ || pkg_list_[fec_pkg_idx_] == NULL || !fec_flag_)
+		{
+			return false;
+		}
+		else
+		{
+			return true;
+		}
+	}
+	else
+	{
+		return false;
+	}
+}
+
+
+bool RsFecEncoder::IsNeedAddRedData()
+{
+	if(m_n_ > m_k_)
+	{
+		if(fec_pkg_idx_ < m_k_ || pkg_list_[fec_pkg_idx_] == NULL || !fec_flag_)
+		{
+			return false;
+		}
+		else
+		{
+			return true;
+		}
+	}
+	else
+	{
+		return false;
+	}
+}
+
+
+
+
+
+int RsFecEncoder::CreateFecHeader(uint8_t *buf, int pt, int index,int pkg_len)
+{
+	uint32_t header = 0;
+
+	int n = m_n_ ;
+
+    if(fec_flag_)
+    {
+// RS FEC headers :
+//
+//    0                   1                   2                   3
+//    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
+//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+//   |F|   block PT  |  timestamp offset         | block length  |     n   |  index  |
+//   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+		header ^= 1 << 31;
+	    header ^= pt << 24;
+	    // header ^= frame_size_ << 10;
+	    // header ^= pkg_len;
+	    header ^= frame_size_ << 12;
+	    header ^= pkg_len<<2;
+	    header ^= n>>3;
+
+	    for(int i=0;i<4;i++)
+	    {
+			buf[i] = (header >> (24-i*8)) & 0xff;
+			// cout <<"buf[i]: "  << (int)buf[i] <<endl;
+		}
+		// buf[4] = (n << 4)^ index ;
+		buf[4] = ((n&0x7) << 5)^ index ;
+	    // cout <<"header: "  << header <<endl;
+	    return 5;
+	}
+	else
+	{
+		buf[0] = pt;
+		return 1;
+	}
+}
+
+
+int RsFecEncoder::Encode(uint8_t *rtp_buf, int buf_len, const uint8_t *payload_data, int payload_size,int8_t pt,uint32_t ts)
+{
+	unsigned total_size = 0;
+    //int8_t pt = pt_;
+
+	if(rtp_buf == NULL || buf_len< 2*max_size_+4)
+	{
+		return -1;
+	}
+
+	if(payload_size == 0)
+	{
+		if(pkg_list_[fec_pkg_idx_] != NULL && fec_size_ > 0)
+		{
+			total_size = CreateFecHeader(rtp_buf,pt,fec_pkg_idx_,payload_size);
+			memcpy(rtp_buf+total_size, pkg_list_[fec_pkg_idx_] , fec_size_);
+			total_size += fec_size_;
+
+			delete [] pkg_list_[fec_pkg_idx_];
+			pkg_list_[fec_pkg_idx_] = NULL;
+
+			fec_pkg_idx_ ++;
+			if(fec_pkg_idx_>=m_n_)
+			{
+				fec_pkg_idx_ = m_k_;
+			}
+		}
+		else
+		{
+			return -1;
+		}
+	}
+	else
+	{
+		if(payload_data == NULL)
+		{
+			return -1;
+		}
+
+		SetFrameSize(ts,payload_size);
+
+		total_size = CreateFecHeader(rtp_buf,pt,src_pkg_cnt_,payload_size);
+
+		memcpy(rtp_buf+total_size, payload_data , payload_size);
+
+		total_size += payload_size;
+
+		if(fec_flag_)
+		{
+			if(IsNeedAddRedData())
+			{
+				memcpy(rtp_buf+total_size, pkg_list_[fec_pkg_idx_] , fec_size_);
+				total_size += fec_size_;
+
+				delete [] pkg_list_[fec_pkg_idx_];
+				pkg_list_[fec_pkg_idx_] = NULL;
+
+				fec_pkg_idx_ ++;
+				if(fec_pkg_idx_ >= m_n_)
+				{
+					fec_pkg_idx_ = m_k_;
+				}
+
+	        }
+
+			if(pkg_list_[src_pkg_cnt_] == NULL)
+			{
+				pkg_list_[src_pkg_cnt_] = new uint8_t[MAX_PAYLOAD_SIZE];
+			}
+
+	        uint8_t *pbuf = pkg_list_[src_pkg_cnt_];
+	        pbuf[0] = payload_size>>8;
+	        pbuf[1] = payload_size&0xff;
+	        pbuf += 2;
+	        memcpy(pbuf, payload_data , payload_size);
+	        memset(pbuf+payload_size, 0 , MAX_PAYLOAD_SIZE - payload_size-2);
+
+	        // memcpy(pkg_list_[src_pkg_cnt_], payload_data , payload_size);
+	        // memset(pkg_list_[src_pkg_cnt_]+payload_size, 0 , MAX_PAYLOAD_SIZE - payload_size);
+	        if(payload_size > max_size_)
+	        {
+				max_size_ = payload_size;
+	        }
+
+	        src_pkg_cnt_ ++;
+	        if(src_pkg_cnt_ == m_k_)
+	        {
+				src_pkg_cnt_ = 0;
+				fec_size_ = max_size_+2;
+				max_size_ = 0;
+
+				if(n_to_set_ != m_n_)
+				{
+					m_n_ = n_to_set_;
+				}
+
+	            for(int i=m_k_;i<m_n_ ; i++)
+	            {
+					if(pkg_list_[i] != NULL)
+					{
+						delete [] pkg_list_[i];
+					}
+					pkg_list_[i] = new uint8_t[fec_size_];
+					fec_encode(GetEncodeMat(m_n_), m_n_, m_k_, pkg_list_, pkg_list_[i], i, fec_size_);
+	            }
+
+	            for(int i=0;i<m_k_ ; i++)
+	            {
+					delete [] pkg_list_[i];
+					pkg_list_[i] = NULL;
+	            }
+	        }
+		}
+	}
+
+	return total_size;
+}
+
+
+
+
+void RsFecEncoder::SetSampleRate(int sample_rate)
+{
+	sample_rate_ = sample_rate;
+
+	//not support samplerate
+}
+
+int RsFecEncoder::GetSampleRate() const
+{
+	// return kSamplerate[sample_rate_id_];
+
+	return sample_rate_;
+}
+
+void RsFecEncoder::SetFrameSize(uint32_t ts,int payload_size)
+{
+	int ts_offset = ts - ts_;
+
+	if(fec_flag_)
+	{
+		if((ts != (ts_ + frame_size_)) || (payload_size <= 1))
+		{
+			fec_flag_ = false;
+			for(int i=0;i<MAX_FEC_N;i++)
+		    {
+				if(pkg_list_[i] != NULL)
+				{
+					delete [] pkg_list_[i];
+					pkg_list_[i] = NULL;
+				}
+		    }
+			if(ts_offset>0 && ts_offset<sample_rate_/10)
+			{
+				fec_flag_ = true;
+				src_pkg_cnt_ = 0;
+			    fec_pkg_idx_ = m_k_;
+			    max_size_ = 0;
+				frame_size_ = ts_offset;
+			}
+			else
+			{
+				frame_size_ = 0;
+			}
+		}
+	}
+	else
+	{
+		if(ts_offset>0 && ts_offset<sample_rate_/10)
+		{
+
+			fec_flag_ = true;
+			src_pkg_cnt_ = 0;
+		    fec_pkg_idx_ = m_k_;
+		    max_size_ = 0;
+
+			frame_size_ = ts_offset;
+
+		}
+		else
+		{
+			frame_size_ = 0;
+		}
+	}
+
+	ts_ = ts;
+}
+
+// int RsFecEncoder::GetFrameSize() const
+// {
+// 	return kFrameSize[frame_size_id_];
+// }
+
+
+void RsFecEncoder::SetN(uint8_t n)
+{
+	if(n> FEC_K && n<=MAX_FEC_N && m_n_ != n)
+	{
+		// m_n_ = n;
+		// src_pkg_cnt_ = 0;
+		// fec_pkg_idx_ = m_k_;
+
+		// need_set_n_ = true;
+		n_to_set_ = n;
+
+		// if(enc_mat_[n-m_k_-1] == NULL)
+		// {
+		// 	enc_mat_[n-m_k_-1] = creat_encode_mat(n,m_k_);
+		// }
+	}
+}
+
+void RsFecEncoder::GetFecParameter(uint8_t &n, uint8_t &k)
+{
+	n = m_n_;
+	k = m_k_;
+}
+
+
+void RsFecEncoder::SetFECStatus(bool enable)
+{
+	enable_ = enable;
+}
+
+bool RsFecEncoder::GetFECStatus() const
+{
+	return enable_;
+}
+
+void RsFecEncoder::SetPt(int8_t pt)
+{
+	pt_ = pt;
+}
+
+int8_t RsFecEncoder::GetPt() const
+{
+	return pt_;
+}
+
+
+
+
+
+RsFecDecoder::RsFecDecoder()
+{
+
+	int i,k;
+    for(i=0;i<MAX_LIST_NUM;i++)
+    {
+		for(k=0;k<FEC_K;k++)
+		{
+			pkg_list_[i][k] = NULL;
+			pkg_index_[i][k] = -1;
+		}
+    }
+
+    for(i=0;i<MAX_FEC_N-FEC_K;i++)
+    {
+		enc_mat_[i] = NULL;
+    }
+
+    for(i=0;i<MAX_LIST_NUM;i++)
+    {
+		dec_para_[i] = NULL;
+    }
+
+    list_cnt_ = 0;
+    decoded_sn_cnt_ = 0;
+    m_n_ = 12;
+
+    for(i=0;i<REG_SN_NUM;i++)
+	{
+		decoded_sn_[i] = 0;
+		decoded_ts_[i] = 0;
+	}
+}
+
+RsFecDecoder::~RsFecDecoder()
+{
+	int i,k;
+    for(i=0;i<MAX_LIST_NUM;i++)
+    {
+		for(k=0;k<FEC_K;k++)
+		{
+			if(pkg_list_[i][k] != NULL)
+			{
+				delete [] pkg_list_[i][k];
+			}
+		}
+    }
+
+    for(i=0;i<MAX_FEC_N-FEC_K;i++)
+    {
+		if(enc_mat_[i] != NULL)
+		{
+			delete [] enc_mat_[i];
+		}
+    }
+
+    for(i=0;i<MAX_LIST_NUM;i++)
+    {
+		if(dec_para_[i] != NULL)
+		{
+			delete [] dec_para_[i];
+		}
+    }
+}
+
+
+int RsFecDecoder::Init()
+{
+
+    init_fec();
+
+    return 0;
+}
+
+int RsFecDecoder::ParseFecHeader(const uint8_t *buf, uint8_t &pt,int &n,int &sid,int &rid,int &frame_size,int &src_size)
+{
+	uint32_t header = 0;
+	int idx;
+
+    for(int i=0;i<4;i++)
+    {
+		header ^= ((uint32_t)buf[i])<<((3-i)*8);
+	}
+
+	//cout <<"header: "  << header <<endl;
+
+	pt = (header<<1)>>25;
+	// n = (header>>(32-11))&(~((~0)<<4));
+	// idx = (header>>(32-15))&(~((~0)<<4));
+	//fid = (header>>10)&(~((~0)<<2));
+	//idr = (header>>12)&(~((~0)<<2));
+	// src_size = (header<<22)>>22;
+	// frame_size = (header<<8)>>18;
+
+	// n = (buf[4]>>4)+1;
+	// idx = buf[4]&0x0f;
+	frame_size = (header<<8)>>20;
+	src_size = (header<<20)>>22;
+
+	n = (buf[4]>>5)^((header&0x3)<<3);
+	idx = buf[4]&0x1f;
+
+	// cout <<"pt: "  << (int)pt <<",src_size: "  << src_size << ",frame_size: "  << frame_size <<",n: "  << n << ",idx: "  << idx <<endl;
+
+    if(n<=FEC_K)
+    {
+		return -1;
+    }
+
+	if(idx<FEC_K)
+	{
+		sid = idx;
+		if(n>2*FEC_K)
+		{
+			rid = n-(FEC_K-idx);
+		}
+		else
+		{
+			rid = idx+FEC_K;
+		}
+	}
+    else
+    {
+		rid = idx;
+		sid = 0;
+
+		if(src_size!=0)
+		{
+			return -1;
+		}
+    }
+
+    m_n_ = n;
+    // frame_size = kSamplerate[idr]*kFrameSize[fid]/1000;
+
+    return 0;
+}
+
+
+uint8_t* RsFecDecoder::GetEncodeMat(int n)
+{
+	if(n<=FEC_K)
+	{
+		return NULL;
+	}
+
+	if(enc_mat_[n-FEC_K-1] == NULL)
+	{
+		enc_mat_[n-FEC_K-1] = creat_encode_mat(n,FEC_K);
+	}
+
+	return enc_mat_[n-FEC_K-1];
+}
+
+uint8_t RsFecDecoder::GetPt(const uint8_t *payload_buf)
+{
+	uint8_t pt = payload_buf[0]&0x7f;
+
+	return pt;
+}
+
+uint32_t RsFecDecoder::GetLostRate()
+{
+	uint32_t ret=0;
+	if(m_n_<25)
+	{
+		ret = ((m_n_-12)*5)>>1;
+	}
+	else
+	{
+		ret = (m_n_-21)*10;
+	}
+
+	if(ret>100)
+	{
+		return 100;
+	}
+	else
+	{
+		return ret;
+	}
+}
+
+int RsFecDecoder::Decode(const uint8_t *payload_buf, int buf_size ,uint16_t sn , uint32_t ts, uint8_t *out_buf, int out_buf_len, uint8_t &out_pt)
+{
+	int n,sid,rid,frame_size,src_size;
+	const uint8_t *pbuf;
+	uint16_t base_sn ;
+	uint32_t base_ts ;
+	int header_size;
+	uint8_t pt;
+
+	if((payload_buf[0]>>7) == 0)
+	{
+		pt = payload_buf[0];
+		header_size = 1;
+		src_size = buf_size - header_size;
+	}
+	else
+	{
+		header_size = 5;
+
+	    pbuf = payload_buf;
+		if(ParseFecHeader(pbuf, pt,n,sid,rid,frame_size,src_size)<0)
+		{
+			// cout <<"decoder parse header error" <<endl;
+			return -1;
+		}
+
+		pbuf += header_size;
+
+		if(src_size == 0)
+		{
+			base_sn = sn - rid;
+			base_ts = ts - (FEC_K-1)*frame_size;
+			AddPkgToList(pbuf, buf_size - header_size,pt,n,rid,base_sn,base_ts,frame_size);
+		}
+		else
+		{
+			base_sn = sn - sid;
+			base_ts = ts - sid*frame_size;
+			AddPkgToList(pbuf, src_size,pt,n,sid,base_sn,base_ts,frame_size);
+
+	        int red_size = buf_size - header_size - src_size;
+	        if(red_size>0)
+	        {
+		        pbuf += src_size;
+				base_sn = sn - rid;
+
+				if(n>2*FEC_K)
+				{
+					base_ts = ts - (rid-(n-2*FEC_K))*frame_size;
+				}
+				else
+				{
+					base_ts = ts - rid*frame_size;
+				}
+				AddPkgToList(pbuf, red_size,pt,n,rid,base_sn,base_ts,frame_size);
+			}
+		}
+
+		for(int i=0;i<MAX_LIST_NUM;i++)
+	    {
+			if(dec_para_[i]!=NULL)
+			{
+				if(dec_para_[i]->pkg_num >=FEC_K)
+				{
+					bool need_decode = false;
+
+					decoded_sn_[decoded_sn_cnt_] = dec_para_[i]->sn;
+					decoded_ts_[decoded_sn_cnt_] = dec_para_[i]->ts;
+					decoded_sn_cnt_ ++;
+					if(decoded_sn_cnt_ >= REG_SN_NUM)
+					{
+						decoded_sn_cnt_ = 0;
+					}
+
+					for(int k=0;k<FEC_K;k++)
+					{
+						if(pkg_index_[i][k] >=  FEC_K)
+						{
+							need_decode = true;
+							break ;
+						}
+					}
+
+					if(!dec_para_[i]->is_decoded && need_decode)
+					{
+						if(fec_decode(GetEncodeMat(dec_para_[i]->n), dec_para_[i]->n, FEC_K, pkg_list_[i], pkg_index_[i], dec_para_[i]->size)== 0)
+						{
+							dec_para_[i]->is_decoded = true;
+						}
+						else
+						{
+							DeletePkgList(i);
+						}
+					}
+					else
+					{
+						DeletePkgList(i);
+					}
+				}
+			}
+		}
+	}
+
+    if(src_size>out_buf_len)
+    {
+		return -1;
+    }
+    else
+    {
+		out_pt = pt;
+		memcpy(out_buf,payload_buf+header_size,src_size);
+		return src_size;
+    }
+}
+
+
+int RsFecDecoder::AddPkgToList(const uint8_t *buf, int buf_size,uint8_t pt,int n,int id,uint16_t base_sn,uint32_t base_ts,int frame_size)
+{
+	int i,k;
+
+	if(buf_size<=1)
+	{
+		return -1;
+	}
+
+	for(i=0;i<REG_SN_NUM;i++)
+	{
+		//if(base_sn == decoded_sn_[i])
+		if(base_ts == decoded_ts_[i])
+		{
+			return 0;
+		}
+	}
+
+    for(i=0;i<MAX_LIST_NUM;i++)
+    {
+		if(dec_para_[i]!=NULL)
+		{
+			//if(dec_para_[i]->sn == base_sn)
+			if(dec_para_[i]->ts == base_ts)
+			{
+				for(k=0;k<FEC_K;k++)
+				{
+					if(pkg_index_[i][k] == id)
+					{
+						return 0;
+					}
+				}
+				if(dec_para_[i]->pkg_num < FEC_K)
+				{
+					pkg_list_[i][dec_para_[i]->pkg_num] = new uint8_t[MAX_PAYLOAD_SIZE];
+					if(id<FEC_K)
+					{
+						uint8_t *pbuf = pkg_list_[i][dec_para_[i]->pkg_num];
+				        pbuf[0] = buf_size>>8;
+				        pbuf[1] = buf_size&0xff;
+				        pbuf += 2;
+				        memcpy(pbuf, buf , buf_size);
+				        memset(pbuf+buf_size, 0 , MAX_PAYLOAD_SIZE - buf_size-2);
+					}
+					else
+					{
+						memcpy(pkg_list_[i][dec_para_[i]->pkg_num] , buf, buf_size);
+						memset(pkg_list_[i][dec_para_[i]->pkg_num]+buf_size,0,MAX_PAYLOAD_SIZE-buf_size);
+					}
+
+					pkg_index_[i][dec_para_[i]->pkg_num] = id;
+
+					dec_para_[i]->pkg_num++;
+					if(id >= FEC_K)
+					{
+						dec_para_[i]->size = buf_size;
+						dec_para_[i]->n = n;
+					}
+				}
+				return 0;
+			}
+		}
+	}
+
+    if(dec_para_[list_cnt_]==NULL)
+    {
+		dec_para_[list_cnt_] = new RsDecoderPara;
+    }
+    else
+    {
+		//LOG(INFO)<< "RsFecDecoder::AddPkgToList delete list,sn="<< dec_para_[list_cnt_]->sn << ",list_cnt_="<< list_cnt_;
+		for(k=0;k<FEC_K;k++)
+		{
+			if(pkg_list_[list_cnt_][k] != NULL)
+			{
+				delete [] pkg_list_[list_cnt_][k];
+				pkg_list_[list_cnt_][k] = NULL;
+			}
+		}
+    }
+
+	//LOG(INFO)<< "AddPkgToList ,sn="<< base_sn<< ",ts="<< base_ts << ",id="<< id<< ",list_cnt_="<< list_cnt_;
+
+	for(k=0;k<FEC_K;k++)
+	{
+		pkg_index_[list_cnt_][k] = -1;
+	}
+
+	pkg_list_[list_cnt_][0] = new uint8_t[MAX_PAYLOAD_SIZE];
+	if(id<FEC_K)
+	{
+	    uint8_t *pbuf = pkg_list_[list_cnt_][0];
+        pbuf[0] = buf_size>>8;
+        pbuf[1] = buf_size&0xff;
+        pbuf += 2;
+        memcpy(pbuf, buf , buf_size);
+        memset(pbuf+buf_size, 0 , MAX_PAYLOAD_SIZE - buf_size-2);
+        dec_para_[list_cnt_]->size = buf_size+2;
+	}
+	else
+	{
+		memcpy(pkg_list_[list_cnt_][0] , buf, buf_size);
+		memset(pkg_list_[list_cnt_][0]+buf_size,0,MAX_PAYLOAD_SIZE-buf_size);
+		dec_para_[list_cnt_]->size = buf_size;
+	}
+
+	pkg_index_[list_cnt_][0] = id;
+
+	dec_para_[list_cnt_]->pkg_num = 1;
+	dec_para_[list_cnt_]->n = n;
+	dec_para_[list_cnt_]->pt = pt;
+	dec_para_[list_cnt_]->sn = base_sn;
+	dec_para_[list_cnt_]->ts = base_ts;
+	//dec_para_[list_cnt_]->size = buf_size;
+	dec_para_[list_cnt_]->is_decoded = false;
+	dec_para_[list_cnt_]->pkg_rd_cnt = 0;
+	dec_para_[list_cnt_]->frame_size = frame_size;
+
+	list_cnt_++;
+	if(list_cnt_>=MAX_LIST_NUM)
+	{
+		list_cnt_ = 0;
+	}
+
+	return 0;
+
+}
+
+
+
+int RsFecDecoder::GetRecoveryData(uint8_t *buf, int buf_len, uint16_t &sn , uint32_t &ts, uint8_t &pt)
+{
+	for(int i=0;i<MAX_LIST_NUM;i++)
+    {
+		if(dec_para_[i]!=NULL)
+		{
+			if(dec_para_[i]->is_decoded )
+			{
+				while(dec_para_[i]->pkg_rd_cnt < FEC_K)
+				{
+					if(pkg_index_[i][dec_para_[i]->pkg_rd_cnt]>=FEC_K)
+					{
+						if(buf_len>=dec_para_[i]->size)
+						{
+							uint8_t *pbuf = pkg_list_[i][dec_para_[i]->pkg_rd_cnt];
+							int pkg_len = (pbuf[0]<<8) ^ pbuf[1];
+							int size;
+							if(pkg_len<dec_para_[i]->size)
+							{
+								size = pkg_len;
+							}
+							else
+							{
+								size = dec_para_[i]->size-2;
+							}
+							memcpy(buf,pbuf+2,size);
+							delete [] pkg_list_[i][dec_para_[i]->pkg_rd_cnt];
+							pkg_list_[i][dec_para_[i]->pkg_rd_cnt] = NULL;
+							sn = dec_para_[i]->sn + dec_para_[i]->pkg_rd_cnt;
+							ts = dec_para_[i]->ts + dec_para_[i]->pkg_rd_cnt*dec_para_[i]->frame_size;
+							pt = dec_para_[i]->pt;
+
+							// cout <<"dec_para_ ts: "  << dec_para_[i]->ts <<",frame_size: "  << dec_para_[i]->frame_size << ",ts: "  << ts<<endl;
+
+							// int size = dec_para_[i]->size;
+							dec_para_[i]->pkg_rd_cnt ++;
+							if(dec_para_[i]->pkg_rd_cnt >= FEC_K)
+							{
+								DeletePkgList(i);
+							}
+
+							return size;
+						}
+						else
+						{
+							return -1;
+						}
+					}
+
+					dec_para_[i]->pkg_rd_cnt ++;
+				}
+				DeletePkgList(i);
+			}
+		}
+	}
+
+    return 0;
+}
+
+
+void RsFecDecoder::DeletePkgList(int index)
+{
+	if(dec_para_[index] != NULL)
+	{
+		delete dec_para_[index];
+		dec_para_[index] = NULL;
+	}
+
+	for(int k=0;k<FEC_K;k++)
+	{
+		if(pkg_list_[index][k] != NULL)
+		{
+			delete [] pkg_list_[index][k];
+			pkg_list_[index][k] = NULL;
+		}
+	}
+}
\ No newline at end of file
diff --git a/modules/rtp_rtcp/source/rs_fec.h b/modules/rtp_rtcp/source/rs_fec.h
new file mode 100644
index 0000000000000000000000000000000000000000..b1dff7d9f93138144a840652020856276e99b352
--- /dev/null
+++ b/modules/rtp_rtcp/source/rs_fec.h
@@ -0,0 +1,144 @@
+#ifndef WEBRTC_MODULES_RTP_RTCP_SOURCE_RS_FEC_H_
+#define WEBRTC_MODULES_RTP_RTCP_SOURCE_RS_FEC_H_
+
+#define RS_FEC_PAYLOAD_TYPE 115
+
+#define FEC_K  6
+#define MAX_FEC_N  31
+#define MAX_PAYLOAD_SIZE  1024
+#define MAX_LIST_NUM  3
+#define REG_SN_NUM  5
+
+class RsFecEncoder
+{
+public:
+	RsFecEncoder(void);
+	~RsFecEncoder(void);
+	int Init(uint8_t n,int sample_rate);
+	void SetSampleRate(int sample_rate);
+	int GetSampleRate() const;
+
+	//int GetFrameSize() const;
+	// void SetK(uint8_t k);
+	void SetN(uint8_t n);
+	void GetFecParameter(uint8_t &n, uint8_t &k);
+	void SetFECStatus(bool enable);//If the parameter to 0, then close the FEC
+	bool GetFECStatus() const;
+	void SetPt(int8_t pt);
+	int8_t GetPt() const;
+	bool IsNeedSendRedPkg();
+
+	int Encode(uint8_t *rtp_buf, int buf_len, const uint8_t *payload_data, int payload_size,int8_t pt,uint32_t ts );
+
+	//int GetPreFrameData(uint8_t *pRTPBuf, int nBufLen, int nHeadLen);
+private:
+	//int AddRedDataToList(const uint8_t *pPayloadData, int len, int8_t pt, uint32_t ts);
+	//int calcRedListLen(uint8_t nMulriple,uint8_t nOffset);
+	int CreateFecHeader(uint8_t *buf, int pt, int index,int pkg_len);
+	bool IsNeedAddRedData();
+	uint8_t *GetEncodeMat(int n);
+	void SetFrameSize(uint32_t ts,int payload_size);
+	//int AddRedData(uint8_t *pBuf, int nBufLen);
+
+	// fec_red_list *m_pFecRedListHeader;
+	// uint8_t m_nDecimalMulripleQ4;
+	// uint32_t m_fecFrameLoopCnt;
+	int m_n_;
+	int m_k_;
+	int src_pkg_cnt_;
+	int fec_pkg_idx_;
+	int max_size_;
+	int fec_size_;
+	uint8_t *enc_mat_[MAX_FEC_N-FEC_K];
+	uint8_t *pkg_list_[MAX_FEC_N];
+	bool enable_;
+	//int8_t m_nRedCount;
+	int8_t pt_;
+	int sample_rate_;
+	//int sample_rate_id_;
+	int frame_size_;
+	//int frame_size_id_;
+
+	//bool need_set_n_;
+	int  n_to_set_;
+	bool fec_flag_;
+	uint32_t ts_;
+	//uint32_t ts_offset_;
+	//CriticalSectionWrapper *_fecCritSect;
+};
+
+
+struct RsDecoderPara
+{
+	uint8_t n;
+	uint8_t pt;
+    uint16_t sn;
+    uint32_t ts;
+    uint16_t size;
+    int pkg_num;
+    bool is_decoded;
+    int pkg_rd_cnt;
+    int frame_size;
+};
+
+
+class RsFecDecoder
+{
+public:
+	RsFecDecoder(void);
+	~RsFecDecoder(void);
+	int Init(void);
+	// void SetSampleRate(int sample_rate);
+	// void GetSampleRate() const;
+	// void SetFrameSize(int size);
+	// void GetFrameSize() const;
+	// // void SetK(uint8_t k);
+	// void SetN(uint8_t n);
+	// void GetFecParameter(uint8_t &n, uint8_t &k);
+	// void SetFECStatus(bool enable);//If the parameter to 0, then close the FEC
+	// bool GetFECStatus() const;
+    uint32_t GetLostRate();
+	uint8_t GetPt(const uint8_t *payload_buf);
+
+	int Decode(const uint8_t *payload_buf, int buf_size ,uint16_t sn , uint32_t ts, uint8_t *out_buf, int out_buf_len, uint8_t &out_pt);
+
+	int GetRecoveryData(uint8_t *buf, int buf_len, uint16_t &sn , uint32_t &ts,uint8_t &pt);
+private:
+	//int AddRedDataToList(const uint8_t *pPayloadData, int len, int8_t pt, uint32_t ts);
+	//int calcRedListLen(uint8_t nMulriple,uint8_t nOffset);
+	int ParseFecHeader(const uint8_t *buf, uint8_t &pt,int &n,int &sid,int &rid,int &frame_size,int &src_size);
+	// int ParseFecHeader(uint8_t *buf, int &n,int &sid,int &rid,int &frame_size,int &src_size);
+	uint8_t *GetEncodeMat(int n);
+	int AddPkgToList(const uint8_t *buf, int buf_size,uint8_t pt,int n,int id,uint16_t base_sn,uint32_t base_ts,int frame_size);
+	void DeletePkgList(int index);
+
+	//bool IsNeedAddRedData();
+	//int AddRedData(uint8_t *pBuf, int nBufLen);
+
+	int m_n_;
+	// int m_k_;
+	int list_cnt_;
+	//int fec_pkg_idx_;
+
+	uint8_t *enc_mat_[MAX_FEC_N-FEC_K];
+	uint8_t *pkg_list_[MAX_LIST_NUM][FEC_K];
+	int pkg_index_[MAX_LIST_NUM][FEC_K];
+	RsDecoderPara *dec_para_[MAX_LIST_NUM];
+
+	uint16_t decoded_sn_[REG_SN_NUM];
+	uint32_t decoded_ts_[REG_SN_NUM];
+	int decoded_sn_cnt_;
+	//bool decoded_list_idx_[2];
+	//int decoded_list_num_;
+
+	//bool enable_;
+	//int8_t m_nRedCount;
+	//int8_t pt_;
+	//int sample_rate_;
+	//int sample_rate_id_;
+	//int frame_size_;
+	//int frame_size_id_;
+	//CriticalSectionWrapper *_fecCritSect;
+};
+
+#endif
diff --git a/modules/rtp_rtcp/source/rtp_sender_audio.cc b/modules/rtp_rtcp/source/rtp_sender_audio.cc
index b826c30e07ba342e012bbeeba22040f0cc636f7d..6aefc053e3fbe5808a4c3f4bf63677a9198d5fc1 100644
--- a/modules/rtp_rtcp/source/rtp_sender_audio.cc
+++ b/modules/rtp_rtcp/source/rtp_sender_audio.cc
@@ -56,9 +56,22 @@ RTPSenderAudio::RTPSenderAudio(Clock* clock, RTPSender* rtp_sender)
       rtp_sender_(rtp_sender),
       absolute_capture_time_sender_(clock) {
   RTC_DCHECK(clock_);
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+  rs_encoder_ = new RsFecEncoder;
+  int n = 8;
+  rs_encoder_->Init(n,48000);
+  rs_encoder_->SetFECStatus(false);
+#endif // WEBRTC_ENABLE_RSFECOPUS
 }
 
-RTPSenderAudio::~RTPSenderAudio() {}
+RTPSenderAudio::~RTPSenderAudio() {
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+  if(rs_encoder_ != NULL)
+  {
+    delete rs_encoder_;
+  }
+#endif // WEBRTC_ENABLE_RSFECOPUS
+}
 
 int32_t RTPSenderAudio::RegisterAudioPayload(absl::string_view payload_name,
                                              const int8_t payload_type,
@@ -148,6 +161,21 @@ bool RTPSenderAudio::SendAudio(const RtpAudioFrame& frame) {
   TRACE_EVENT_ASYNC_STEP1("webrtc", "Audio", frame.rtp_timestamp, "Send",
                           "type", FrameTypeToString(frame.type));
 
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+  if(frame.payload_id == RS_FEC_PAYLOAD_TYPE) {
+    if(rs_encoder_->GetFECStatus() == false)
+    {
+      rs_encoder_->SetFECStatus(true);
+      rs_encoder_->SetN(8);
+      rs_encoder_->SetPt(RS_FEC_PAYLOAD_TYPE);
+    }
+  }
+
+  const uint8_t* payload_data = frame.payload.data();
+  size_t payload_size = frame.payload.size();
+  int8_t payload_type = frame.payload_id;
+#endif // WEBRTC_ENABLE_RSFECOPUS
+
   // From RFC 4733:
   // A source has wide latitude as to how often it sends event updates. A
   // natural interval is the spacing between non-event audio packets. [...]
@@ -270,9 +298,39 @@ bool RTPSenderAudio::SendAudio(const RtpAudioFrame& frame) {
     packet->SetExtension<AbsoluteCaptureTimeExtension>(*absolute_capture_time);
   }
 
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+  if (rs_encoder_->GetFECStatus()){//
+    uint8_t data_buffer[IP_PACKET_SIZE];
+    int8_t  pt = rs_encoder_->GetPt();
+    size_t fec_payload_size = rs_encoder_->Encode(data_buffer,
+                                                  IP_PACKET_SIZE,
+                                                  payload_data,
+                                                  payload_size,
+                                                  payload_type,
+                                                  frame.rtp_timestamp);
+    uint8_t* payload = packet->AllocatePayload(fec_payload_size);
+    if (!payload) {
+      return false;
+    }
+    if (fec_payload_size == 0) {
+      RTC_LOG(LS_ERROR) << "rs fec encode failed with " << payload_size;
+      return true;
+    }
+    memcpy(payload, data_buffer, fec_payload_size);
+    packet->SetPayloadType(pt);
+    packet->SetMarker(false);
+  }
+  else {
+    uint8_t* payload = packet->AllocatePayload(payload_size);
+    if (!payload)  // Too large payload buffer.
+      return false;
+    memcpy(payload, payload_data, payload_size);
+  }
+#else
   uint8_t* payload = packet->AllocatePayload(frame.payload.size());
   RTC_CHECK(payload);
   memcpy(payload, frame.payload.data(), frame.payload.size());
+#endif // WEBRTC_ENABLE_RSFECOPUS
 
   {
     MutexLock lock(&send_audio_mutex_);
@@ -289,9 +347,75 @@ bool RTPSenderAudio::SendAudio(const RtpAudioFrame& frame) {
   if (first_packet_sent_()) {
     RTC_LOG(LS_INFO) << "First audio RTP packet sent to pacer";
   }
+
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+  if (rs_encoder_->GetFECStatus()){//
+      while(rs_encoder_->IsNeedSendRedPkg()){
+      std::unique_ptr<RtpPacketToSend> packet_red = rtp_sender_->AllocatePacket();
+      packet_red->SetMarker(MarkerBit(frame.type, payload_type));
+      packet_red->SetPayloadType(payload_type);
+      packet_red->SetTimestamp(frame.rtp_timestamp);
+      packet_red->set_capture_time(clock_->CurrentTime());
+      // Update audio level extension, if included.
+      packet_red->SetExtension<AudioLevel>(
+          frame.type == AudioFrameType::kAudioFrameSpeech,
+          frame.audio_level_dbov.value_or(127));
+
+      uint8_t data_buffer[IP_PACKET_SIZE];
+      int8_t  pt = rs_encoder_->GetPt();
+      size_t fec_payload_size = rs_encoder_->Encode(data_buffer,
+                                                    IP_PACKET_SIZE,
+                                                    NULL,
+                                                    0,
+                                                    payload_type,
+                                                    frame.rtp_timestamp);
+      uint8_t* payload = packet_red->AllocatePayload(fec_payload_size);
+      if (!payload) {
+        return false;
+      }
+      if (fec_payload_size == 0) {
+        RTC_LOG(LS_ERROR) << "rs fec encode failed with " << payload_size;
+        return true;
+      }
+      memcpy(payload, data_buffer, fec_payload_size);
+      packet_red->SetPayloadType(pt);
+      packet_red->SetMarker(false);
+
+      // if (!rtp_sender_->AssignSequenceNumber(packet_red.get()))
+      //   return false;
+
+      TRACE_EVENT_ASYNC_END2("webrtc", "Audio", frame.rtp_timestamp, "timestamp",
+                              packet_red->Timestamp(), "seqnum",
+                              packet_red->SequenceNumber());
+
+      packet_red->set_packet_type(RtpPacketMediaType::kAudio);
+      packet_red->set_allow_retransmission(false);
+      std::vector<std::unique_ptr<RtpPacketToSend>> packets(1);
+      packets[0] = std::move(packet_red);
+      rtp_sender_->EnqueuePackets(std::move(packets));
+    }
+  }
+#endif // WEBRTC_ENABLE_RSFECOPUS
+
   return true;
 }
 
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+int32_t RTPSenderAudio::SetRsPara(uint8_t n) {
+	rs_encoder_->SetN(n);
+	return 0;
+}
+
+int32_t RTPSenderAudio::SetRsStatus(bool enable) {
+	rs_encoder_->SetFECStatus(enable);
+	return 0;
+}
+
+bool RTPSenderAudio::GetRsStatus() const {
+	return rs_encoder_->GetFECStatus();
+}
+#endif // WEBRTC_ENABLE_RSFECOPUS
+
 // Send a TelephoneEvent tone using RFC 2833 (4733)
 int32_t RTPSenderAudio::SendTelephoneEvent(uint8_t key,
                                            uint16_t time_ms,
diff --git a/modules/rtp_rtcp/source/rtp_sender_audio.h b/modules/rtp_rtcp/source/rtp_sender_audio.h
index 662f908216e8f18de6036ce5d79cfe0807ba0dcf..d7d96febce1ed3cca0f5e41ee5bc43beda34dd64 100644
--- a/modules/rtp_rtcp/source/rtp_sender_audio.h
+++ b/modules/rtp_rtcp/source/rtp_sender_audio.h
@@ -21,6 +21,9 @@
 #include "modules/rtp_rtcp/source/absolute_capture_time_sender.h"
 #include "modules/rtp_rtcp/source/dtmf_queue.h"
 #include "modules/rtp_rtcp/source/rtp_sender.h"
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+#include "modules/rtp_rtcp/source/rs_fec.h"
+#endif // WEBRTC_ENABLE_RSFECOPUS
 #include "rtc_base/one_time_event.h"
 #include "rtc_base/synchronization/mutex.h"
 #include "rtc_base/thread_annotations.h"
@@ -67,6 +70,14 @@ class RTPSenderAudio {
   // Send a DTMF tone using RFC 2833 (4733)
   int32_t SendTelephoneEvent(uint8_t key, uint16_t time_ms, uint8_t level);
 
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+  int32_t SetRsPara(uint8_t n);
+
+  int32_t SetRsStatus(bool enable);
+
+  bool GetRsStatus() const;
+#endif // WEBRTC_ENABLE_RSFECOPUS
+
  protected:
   bool SendTelephoneEventPacket(
       bool ended,
@@ -82,6 +93,10 @@ class RTPSenderAudio {
 
   Mutex send_audio_mutex_;
 
+#ifdef WEBRTC_ENABLE_RSFECOPUS
+  RsFecEncoder* rs_encoder_;
+#endif // WEBRTC_ENABLE_RSFECOPUS
+
   // DTMF.
   bool dtmf_event_is_on_ = false;
   bool dtmf_event_first_packet_sent_ = false;
diff --git a/webrtc.gni b/webrtc.gni
index 173d66c7910dfea708b53444d8a4348a20329609..d93fca30a260a4f9d35cd3080e4cc285f0874324 100644
--- a/webrtc.gni
+++ b/webrtc.gni
@@ -189,6 +189,9 @@ declare_args() {
   rtc_use_h264 =
       proprietary_codecs && !is_android && !is_ios && !(is_win && !is_clang)
 
+  # rsfecopus 音频编码器开关，默认在mac和Windows上开启
+  rtc_enable_rsfecopus = is_win || is_mac
+
   # Enable to use H265
   rtc_use_h265 = proprietary_codecs
 
